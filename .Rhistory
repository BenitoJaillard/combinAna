plot.box.elements(res$fct[index], mOccur[index, , drop = FALSE],
ordre   = ref.all$motif[indOrd],
sres    = ref.xpr[[ipr]][indOrd, ],
elt.wdw = ywdw,
ylim    = range(res$fct),
titre   = titre2,
opt.aov = opt.aov, pvalue = pvalue,
opt.hor = opt.horizontal )
}
} else {
# plot all the figure
plot.box.elements(res$fct, mOccur,
ordre   = ref.all$motif[indOrd],
sres    = ref.all[indOrd, ],
ylim    = range(res$fct),
titre   = titre,
opt.aov = opt.aov, pvalue = pvalue,
opt.hor = opt.horizontal )
# plot only the higher part of the figure
titre2 <- paste(titre, "zoom  Higher part", sep = ".")
plot.box.elements(res$fct, mOccur,
ordre   = ref.all$motif[indOrd],
sres    = ref.all[indOrd, ],
elt.wdw = ywdw,
titre   = titre2,
opt.aov = opt.aov, pvalue = pvalue,
opt.hor = opt.horizontal )
}
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# Compute Statistiques for each Assembly Motif
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#  mStats <- compute.mStats.byMotif(res, nbOpt, AssNoms)
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# Plot the hierarchical tree of motifs
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
mot.tre <- FALSE
if (mot.tre == TRUE) {
index <- which(res$xpr == setXpr[1])
tree.mot <- cluster.motifs(affectElt, mOccur[index, , drop = FALSE],
Fobs[index],
opt.meth = "divisive")
plot.tree(tree.mot, col = "black", titre)
}
#xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#
#                             END of file myPLOT.R
#
#xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
rm(list = ls())
source("myLibraries.R")
source("myTools.R")
source("myStats.R")
source("myTree.R")
source("myCombinat.R")
source("myPlot.R")
source("mySeparating.R")
source("myPredicting.R")
source("myClustering.R")
#xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#
#    MAIN
#
#xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
nom       <- c("WHMX")
nbElt     <- 16          # nb of species
nbXpr     <- 32          # nb of harvests ("xpr" for eXPeRiment)
conventionalFG  <- c(1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4)
# conventional functional groups
nbFG    <- length(unique(conventionalFG))
enregistre <- TRUE
#enregistre <- FALSE     # record as standard PDF file, or not
#xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#
#        SCRIPT for Complete Standard Treatment of Dynamic DataSet
#
#                             BenoÃ®t JAILLARD
#                              Janvier 2018
#
#xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
affectElt <- rep(1, nbElt)
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
if (!file.exists(nom)) dir.create(nom)
filename <- paste(nom, "csv", sep = ".")
data     <- read.table(filename, header = TRUE, sep = ",")
setXpr  <- colnames(data)[(1 + nbElt + 1):
(1 + nbElt + nbXpr)]
setXpr
# [1] "X2015_Cle_N._1"   "X2015_Cle_N._1.1" "X2015_Cle_N._2"
#  "X2015_Cle_N._2.1" "X2015_Dij_N._1"   "X2015_Dij_N._1.1"
# [7] "X2015_Dij_N._2"   "X2015_Dij_N._2.1" "X2015_Ren_N._1"
#   "X2015_Ren_N._1.1" "X2015_Ren_N._2"   "X2015_Ren_N._2.1"
# [13] "X2015_Tou_N._1"   "X2015_Tou_N._1.1" "X2015_Tou_N._2"
#   "X2015_Tou_N._2.1" "X2016_Cle_N._1"   "X2016_Cle_N._1.1"
# [19] "X2016_Cle_N._2"   "X2016_Cle_N._2.1" "X2016_Dij_N._1"
#   "X2016_Dij_N._1.1" "X2016_Dij_N._2"   "X2016_Dij_N._2.1"
# [25] "X2016_Ren_N._1"   "X2016_Ren_N._1.1" "X2016_Ren_N._2"
#   "X2016_Ren_N._2.1" "X2016_Tou_N._1"   "X2016_Tou_N._1.1"
# [31] "X2016_Tou_N._2"   "X2016_Tou_N._2.1"
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#  Combinatorial analysis experiment by experiment
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
nbXpr  <- length(setXpr)       #  nb of harvests ("xpr" for eXPeRiment)
tmp1   <- data[ , c(1:(1 + nbElt))]
tmp2   <- data[ , setXpr]
data   <- cbind(tmp1, tmp2)
colnames(data)
# Beginning of loop                                                        ####
ipr <- 1
for (ipr in seq_along(setXpr)) {
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# Read raw data
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# matrix of species occurrency
mOccur           <- as.matrix(data[ , 1 + (1:nbElt)])
rownames(mOccur) <- as.character(data[ , 1])
# function of species assemblages
Fobs   <- as.vector(as.numeric(unlist(data[ , (1 + nbElt) + ipr])))
#  average multiple assemblages
tmp    <- rm.dual.assemblies(mOccur, Fobs)
mOccur <- tmp$mat
Fobs   <- tmp$fct
size   <- apply(mOccur, MARGIN = 1, FUN = sum)
nbAss    <- length(Fobs)
xpr      <- rep(setXpr[ipr], nbAss)
# vectors of figures x colours
figures  <- check.symbol(figures,  max(nbAss, nbElt))
couleurs <- check.symbol(couleurs, max(nbAss, nbElt))
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#   Multiplicative separating of diversity effects of communities
#   (see Jaillard et al., 2018: Methods in Ecology and Evolution)
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
source("nyBeginning.script.R")
nbAss  <- length(Fobs)
xpr    <- rep(setXpr[ipr], nbAss)
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#   Plot community function in biplot alpha x beta
#   (see Jaillard et al., 2018: Methods in Ecology and Evolution)
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
titre <- paste("Separating", setXpr[ipr], sep = ".")
filename <- paste(nom, titre, sep = "/")
open.pdf(enregistre, filename)
source("nySeparating.script.R")
close.pdf(enregistre)
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#   Predict community function
#             using the species tree based on community alpha x beta
#   (see Jaillard et al., 2018: Methods in Ecology and Evolution)
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
titre <- paste("Predicting", setXpr[ipr], sep = ".")
filename <- paste(nom, titre, sep = "/")
open.pdf(enregistre, filename)
source("nyPredicting.script.R")
close.pdf(enregistre)
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#   Combinatorial analysis of observed community function
#    (see Jaillard et al., 2018: PLoS ONE)
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# Fobs ####
titre <- paste("Fobs", setXpr[ipr], sep = ".")
filename <- paste(nom, titre, sep = "/")
open.pdf(enregistre, filename)
open.txt(enregistre, filename)
tree.cal <- cluster.elements(mOccur, Fobs, opt.mean = "gmean")
write.tree(filename, tree.cal)
tree.cal <- read.tree(filename)
res.prd  <- predict.function(tree.cal, mOccur, Fobs, opt.mean = "gmean")
nbOpt    <- first.argmin(res.prd$tStats[, "AICc"])
plot.prediction(res.prd,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, mOccur,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, mOccur,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
tre.prd = TRUE, col = couleurs[conventionalFG])
close.pdf(enregistre)
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#   Combinatorial analysis of Interaction effect (alpha)
#   (see Jaillard et al., 2018: PLoS ONE)
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# alpha ####
titre <- paste("alpha", setXpr[ipr], sep = ".")
filename <- paste(nom, titre, sep = "/")
open.pdf(enregistre, filename)
open.txt(enregistre, filename)
tree.cal <- cluster.elements(mOccur, alpha, opt.mean = "gmean")
write.tree(filename, tree.cal)
tree.cal <- read.tree(filename)
res.prd <- predict.function(tree.cal, mOccur, alpha, opt.mean = "gmean")
plot.prediction(res.prd,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, mOccur,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, mOccur,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
tre.prd = TRUE, col = couleurs[conventionalFG])
close.pdf(enregistre)
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#   Combinatorial analysis of Composition effect (beta)
#   (see Jaillard et al., 2018: PLoS ONE)
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# beta ####
titre <- paste("beta", setXpr[ipr], sep = ".")
filename <- paste(nom, titre, sep = "/")
open.pdf(enregistre, filename)
open.txt(enregistre, filename)
tree.cal <- cluster.elements(mOccur, beta, opt.mean = "amean")
write.tree(filename, tree.cal)
tree.cal <- read.tree(filename)
res.prd  <- predict.function(tree.cal, mOccur, beta, opt.mean = "amean")
nbOpt    <- min(first.argmin(res.prd$tStats[ ,"AICc"]), 4)
plot.prediction(res.prd,
nbOpt   = nbOpt,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, mOccur,
nbOpt   = nbOpt,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, mOccur,
nbOpt   = nbOpt,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
tre.prd = TRUE, col = couleurs[conventionalFG])
close.pdf(enregistre)
}
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#  Combinatorial analysis of all experiments together
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# ALL ####
# Beginning of loop                                                        ####
# variables over experiments
colnames(data)[(2 + nbElt):(1 + nbElt + nbXpr)]
tmp <- mat <- as.matrix(data[ , (2 + nbElt):(1 + nbElt + nbXpr)])
for (indCol in 1:nbXpr) print(c(indCol, which(is.na(mat[ , indCol]))))
# [1] 13  2  9 24
# [1] 14  25
# [1] 16  6 17 26
indCol <- 13
indRow <- which(is.na(mat[ , indCol]))
for (ind in indRow) tmp[ind, indCol] <- interpolate(ind, indCol, mat)
indCol <- 14
indRow <- which(is.na(mat[ , indCol]))
for (ind in indRow) tmp[ind, indCol] <- interpolate(ind, indCol, mat)
indCol <- 16
indRow <- which(is.na(mat[ , indCol]))
for (ind in indRow) tmp[ind, indCol] <- interpolate(ind, indCol, mat)
data[ , (2 + nbElt):(1 + nbElt + nbXpr)] <- tmp
ALPHA <- BETA <- ALPHAELT <- BETAELT <- fOBS <- FOBS <- FOBSF <-
FMONO <- FSCALE <- MOCCUR <- XPR <- NULL
ipr <- 1
for (ipr in seq_along(setXpr)) {
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# Read raw data
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# matrix of species occurrency
mOccur <- as.matrix(data[ , 1 + (1:nbElt)])
Fobs   <- as.vector(as.numeric(unlist(data[ , (1 + nbElt) + ipr])))
rownames(mOccur) <- names(Fobs) <- as.character(data[ , 1])
#  average multiple assemblages
tmp    <- rm.dual.assemblies(mOccur, Fobs)
mOccur <- tmp$mat
Fobs   <- tmp$fct
size   <- apply(mOccur, MARGIN = 1, FUN = sum)
nbAss    <- length(Fobs)
xpr      <- rep(setXpr[ipr], nbAss)
# vectors of figures x colours
figures  <- check.symbol(figures,  max(nbAss, nbElt))
couleurs <- check.symbol(couleurs, max(nbAss, nbElt))
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#   Multiplicative separating of diversity effects of communities
#   (see Jaillard et al., 2018: Methods in Ecology and Evolution)
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
source("nyBeginning.script.R")
size   <- apply(mOccur, MARGIN = 1, FUN = sum)
nbAss  <- length(Fobs)
xpr    <- rep(setXpr[ipr], nbAss)
ALPHA     <- c(ALPHA, alpha)
BETA      <- c(BETA,  beta)
ALPHAELT  <- c(ALPHAELT, alphaElt)
BETAELT   <- c(BETAELT,  betaElt)
FOBSF     <- c(FOBSF, Fobs)
FOBS      <- c(FOBS,  Fobs / amean(Fobs))
fOBS      <- c(fOBS,  fobs)
FMONO     <- c(FMONO, Fmono)
FSCALE    <- c(FSCALE, rep(Fscale, nbAss))
XPR       <- c(XPR,   xpr)
if (length(MOCCUR) > 0) {
index <- which(colnames(mOccur) %in% colnames(MOCCUR))
mat   <- matrix(0, nrow = dim(mOccur)[1], ncol = dim(MOCCUR)[2],
dimnames = list(rownames(mOccur), colnames(MOCCUR)))
mat[ , index] <- mOccur
} else {
mat <- mOccur
}
MOCCUR <- rbind(MOCCUR, mat)
}
SIZE   <- apply(MOCCUR, MARGIN = 1, FUN = sum)
newFSCALE <- amean(unique(FSCALE))
newFSCALE
GAMMA     <- FSCALE / newFSCALE
unique(GAMMA)
alpha    <- ALPHA
beta     <- BETA
alphaElt <- ALPHAELT
betaElt  <- BETAELT
Fobs     <- FOBSF     # observed community function
fobs     <- fOBS      # relative community function
mOccur   <- MOCCUR
Fmono    <- FMONO
Fscale   <- unique(FSCALE)
xpr      <- XPR
nbAss    <- length(XPR)
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#   Plot community function in biplot alpha x beta over all experiments
#   (see Jaillard et al., 2018: Methods in Ecology and Evolution)
#
#        generate FIGURE 1
#
##ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
titre <- c("all.Separating")
filename <- paste(nom, titre, sep = "/")
open.pdf(enregistre, filename)
source("nySeparating.script.R")
close.pdf(enregistre)
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#   Plot mean function of communities containing a given species
#         in biplot alpha x beta over all experiments
#   (see Jaillard et al., 2018: Methods in Ecology and Evolution)
#
#        generate FIGURE 2
#
##ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
titre <- c("all.Dynamics")
filename <- paste(nom, titre, sep = "/")
open.pdf(enregistre, filename)
plot.dynamics(ALPHA, BETA, MOCCUR, xpr = XPR,
figs = conventionalFG, cols = conventionalFG)
close.pdf(enregistre)
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#   Combinatorial analysis of OBSERVED biomass over all experiments
#
#        generate FIGURES 3, 4, S1 & S2 for OBSERVED BIOMASS
#          (not used in this paper)
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# all.FOBSF ####
titre <- c("all.FOBSF")
filename <- paste(nom, titre, sep = "/")
open.pdf(enregistre, filename)
open.txt(enregistre, filename)
tree.cal <- cluster.elements(MOCCUR, FOBS, xpr = XPR, opt.mean = "gmean")
write.tree(filename, tree.cal)
tree.cal <- read.tree(filename)
res.prd <- predict.function(tree.cal, MOCCUR, FOBS,
xpr = XPR, opt.mean = "gmean")
plot.prediction(res.prd,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, MOCCUR,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, MOCCUR,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
tre.prd = TRUE, col = couleurs[conventionalFG])
close.pdf(enregistre)
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#   Combinatorial analysis of RELATIVE biomass over all experiments
#
#        generate FIGURES 3, 4, S1 & S2 for RELATIVE BIOMASS
#          (not used in this paper)
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# all.fOBS ####
titre <- c("all.fOBS")
filename <- paste(nom, titre, sep = "/")
open.pdf(enregistre, filename)
open.txt(enregistre, filename)
tree.cal <- cluster.elements(MOCCUR, fOBS, xpr = XPR, opt.mean = "gmean")
write.tree(filename, tree.cal)
tree.cal <- read.tree(filename)
res.prd <- predict.function(tree.cal, MOCCUR, fOBS,
xpr = XPR, opt.mean = "gmean")
nbOpt <- min(4, first.argmin(res.prd$tStats[ , "AICc"]))
summary(aov(res.prd$fct ~ as.factor(res.prd$mMotifs[nbOpt, ])))
summary(aov(res.prd$mPrd[nbOpt, ] ~ as.factor(res.prd$mMotifs[nbOpt, ])))
plot.prediction(res.prd,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, MOCCUR,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, MOCCUR,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
tre.prd = TRUE, col = couleurs[conventionalFG])
close.pdf(enregistre)
fOBS.prd   <- res.prd
fOBS.nbOpt <- nbOpt
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#   Combinatorial analysis of INTERACTION EFFECT over all experiments
#
#        generate FIGURES 3, 4, S1 & S2 for INTERACTION EFFECT
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# all.ALPHA ####
titre <- c("all.ALPHA")
filename <- paste(nom, titre, sep = "/")
open.pdf(enregistre, filename)
open.txt(enregistre, filename)
tree.cal <- cluster.elements(MOCCUR, ALPHA, xpr = XPR, opt.mean = "gmean")
write.tree(filename, tree.cal)
tree.cal <- read.tree(filename)
res.prd <- predict.function(tree.cal, MOCCUR, ALPHA,
xpr = XPR, opt.mean = "gmean")
nbOpt <- min(4, first.argmin(res.prd$tStats[ , "AICc"]))
summary(aov(res.prd$fct ~ as.factor(res.prd$mMotifs[nbOpt, ])))
summary(aov(res.prd$mPrd[nbOpt, ] ~ as.factor(res.prd$mMotifs[nbOpt, ])))
plot.prediction(res.prd,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, MOCCUR,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, MOCCUR,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
tre.prd = TRUE, col = couleurs[conventionalFG])
close.pdf(enregistre)
ALPHA.prd   <- res.prd
ALPHA.nbOpt <- nbOpt
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
#
#   Combinatorial analysis of COMPOSITION EFFECT over all experiments
#
#        generate FIGURES 3, 4, S1 & S2 for COMPOSITION EFFECT
#
#oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# all.BETA ####
titre <- c("all.BETA")
filename <- paste(nom, titre, sep = "/")
open.pdf(enregistre, filename)
open.txt(enregistre, filename)
tree.cal <- cluster.elements(MOCCUR, BETA, xpr = XPR, opt.mean = "amean")
write.tree(filename, tree.cal)
tree.cal <- read.tree(filename)
res.prd <- predict.function(tree.cal, MOCCUR, BETA,
xpr = XPR, opt.mean = "amean")
nbOpt <- min(4, first.argmin(res.prd$tStats[ , "AICc"]))
summary(aov(res.prd$fct ~ as.factor(res.prd$mMotifs[nbOpt, ])))
summary(aov(res.prd$mPrd[nbOpt, ] ~ as.factor(res.prd$mMotifs[nbOpt, ])))
plot.prediction(res.prd,
nbOpt   = nbOpt,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, MOCCUR,
nbOpt   = nbOpt,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
opt.all = TRUE)
plot.clustering(tree.cal, res.prd, MOCCUR,
nbOpt   = nbOpt,
titre   = titre,
opt.aov = TRUE, pvalue = 0.05,
tre.prd = TRUE, col = couleurs[conventionalFG])
close.pdf(enregistre)
BETA.prd   <- res.prd
BETA.nbOpt <- nbOpt
setwd("D:/github/combinAna")
